\section{Overview on Development Setup}

A setup for development is explained in table~\ref{tab:requirements}. The most basic components are 
required for hands-on development. Main issue is a python interpreter and common libraries.\footnote{For example
cherrypy, pyserial and optionally a module for SQL-bindings in Python.}

Figure~\ref{setupic} shows the last version of the used development system. The keyboard and monitor on the host machine
is just used to monitor debug output and use the included \textsl{interactive} mode on the \textsc{WSN}.\footnote{So you can 
type in commands meant for nodes on the host machine instead of using the RESTful http-access}

\ref{nodepic} and \ref{hostpic} show the expected results after a clean startup. The controller identifies itself with a
self-chosen name and exchanges basic data for database population.
 

\begin{table}[h] 
\centering 
\begin{tabular}{|l||l|} 
General Component & Specific Component\\ 
\hline 
i86 host machine & 300MHz, 512MB\\ 
host OS & Debian stable(Squeeze) \\ 
Python Interpreter & Python 2.7 with pyserial \\ 
Database & MySQL\footnote{A local sqlite version with reduced functionality has no additional requirements} \\ 
1 Wireless Sensor Node as Controller & Renesas ZMD28-BRD \\
n Wireless Sensor Node as Client & Renesas ZMD28-BRD \\ 
\end{tabular} 
\caption{ Table of Requirements} 
\label{tab:requirements} 
\end{table}


\begin{figure}[H]
   \centering
   \includegraphics[width=0.8\textwidth]{pic/whole_setup.jpg}%
   \caption{Glimpse on the development setup}
   \label{setupic}%
\end{figure}

A disc image will be distributed along this document but a download is also available.\footnote{\url{XXXXXXXXXXXXXX} and use 
\url{http://clonezilla.org} as your tool of restoration.}

Look up on chapter~\ref{sec:install} on page~\pageref{sec:install} for detailled installation instructions without using the disc image.

For general x86-machine there are not specific demands 

\begin{figure}[H]
   \centering
   \includegraphics[width=0.8\textwidth]{pic/controller.jpg}%
   \caption{Renesas Node with Custom Programming and Serial Connector}
   \label{nodepic}%
\end{figure}

For the setup we tried to not distract ourselves from the goal so we tested with just one client. The final version is not restricted
to any finite number by the translator but only by available hardware and lower protocol stack's requirements.

\begin{figure}[H]
   \centering
   \includegraphics[width=0.8\textwidth]{pic/host_machine.jpg}%
   \caption{Console Output on Host Machine}
   \label{hostpic}%
\end{figure}

Figure~\ref{pic:hostpic} shows the state of the middleware after initialisation. On default a USB-FTDI adaptor is used to enable serial over USB.
In this test we used plain RS232 connections for accessing the controlling node. The parametres of the hardware part called \textit{SerialReader.py}
are very extensive so use the code or see a console output by using the standard \textit{--help} parametre upon start.

The next step is to identify all available nodes. Firstly, the controller gets the command \textit{+WWSNID} to report example identification numbers.
Our example shows our room number in our college where the node was resting on the table as shown in picture~\ref{pic:nodepic}. It is possible 
to use whatever means of identification but it should be unique due to its importance as database key. Every node has its own 
entry and is adressable if the lower stack on the controller/router enables it.

Forthermore visible is the ZigBee identifier for \textsc{Pan Id} and \textsc{Channel Id}. Every device has its own identifier in the ZigBee specification
but it is not required on the middleware's side. Some example output is reported by the node as you can see on the screenshot.\footnote{The screenshot
    is the debug output from the host machine. This is not the default as the host could possibly run headless. Be aware that ZigBee devices may influence
other nodes which are not part of your project. We experienced this quirk and had a lot of fun to find out why.}

\newpage
\section{The development method}

For development there have been used different approaches. Most of this project has been developed by the use of agile methods, 
what means that a feature was implemented and then tested. If it worked properly, it has been committed to a central repository. 
Critical parts like the \textit{Controller} and the \textit{DataRepository} classes have been developed by using the test-driven-development, 
where first tests have been written and afterwards the corresponding methods. This last development technique had their advantages and made 
the expansion of the \textit{DataRepository} class with a second database layer - MySQL - much easier and faster: each test case 
created for the first database layer - SQLite - had also to work with the newly implemented layer for MySQL.

The approach for the hardware backend was similar but more experiemental due to the serial nature of communication between node and host machine. Only
few tests were used as there were different approaches in the lifecycle of this project: a thread-based approach was not found optimal because 
of error in the \textit{pySerial} module and hardware design flaws for threading. A buffer was inserted instead which will cache a limited amount of commands which
will be sent on the next cycle. The cycles were parted between reading and writing.

\section{Class diagrams}
\subsection{The Controller class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/Controller.png}%
   \caption{The Controller class}
   \label{Controllerpic}%
\end{figure}

The \textit{Controller} class is the central part of this project. It corresponds to the controller part of the Model-View-Controller design pattern.

Like in any other MVC applications the controller receives and handles input and requests of the user and also of any other external modules. 
It validates the input and decides what to do with the data passed to the controller, 
for example if the controller should save it to the model or retrieve some data from the repository and return it as response.

Applied to this project the \textit{Controller} class receives requests from the webserver to retrieve stored data for a 
WSN and also to save commands for a WSN in the database, which is used as a queue. The second actor of this class is the 
\textit{SerialReader} class, which also accesses the controller to save its identification credentials, 
to pass its read sensor data to the controller for saving and to retrieve new commands from the queue.

The last possible user is the setup script, which accesses the controller for maintenance tasks, like removing all data from the datarepository.



\newpage
\subsection{The ControllerTest class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/ControllerTest.png}%
   \caption{ControllerTest class, unittest for the Controller class}
   \label{ControllerTestpic}%
\end{figure}

This unittest was written to test the \textit{Controller} class and their functionality. 

\newpage
\subsection{DataRepository class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/DataRepository.png}%
   \caption{DataRepository class, which handles the model}
   \label{DataRepositorypic}%
\end{figure}

The \textit{DataRepository} class is the main model class of this project. 
Their goal is to store and retrieve information and data from the database. 
Nearly all methods contain SQL instructions, 
which will be executed by the use of an \textit{DBConnection} object, which contain an actual database connection.

\newpage
\subsection{DataRepositoryTest class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/DataRepositoryTest.png}%
   \caption{DataRepositoryTest class, unittest for the DataRepository class}
   \label{DataRepositoryTestpic}%
\end{figure}

\newpage
\subsection{DBConnection class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/DBConnection.png}%
   \caption{DBConnection class, a database layer}
   \label{DBConnectionpic}%
\end{figure}

The sole purpose of the \textit{DBConnection} class is to return a open database connection or the caller. 

\newpage
\subsection{EnhancedSerial class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/EnhancedSerial.png}%
   \caption{EnhancedSerial reader class}
   \label{EnhancedSerialpic}%
\end{figure}

\textit{EnhancedSerial} is a part of \url{http://pyserial.sf.net}{pyserial}  written by \href{mailto:cliechti@gmx.net}{C. Liechti} in 2002.
It is a huge improvement in comparision to the default serial line communication class. For details please look into the code.


\newpage
\subsection{LazyData class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/LazyData.png}%
   \caption{LazyData class}
   \label{LazyDatapic}%
\end{figure}

\textit{LazyData} is a singleton based on the work of Alan Felice. Mainly it serves as a data buffer for the serial output from the host to the node. 
As mentioned by~\cite{GammaHelmJohnsonVlissides199711} the singleton only allows one instance which is accessible throughout every object. It was
heaviliy modified by us to enable the usage for the serial reader module.

\newpage
\subsection{Translator class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/Translator.png}%
   \caption{Translator class}
   \label{Translatorpic}%
\end{figure}

The translation abstract class is the heart of the middleware. It enables the transition between the various language by providing a basis for further 
abstraction.

\subsubsection{MedusaTranslator class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/MedusaTranslator.png}%
   \caption{MedusaTranslator class}
   \label{MedusaTranslatorpic}%
\end{figure}

The Medusa is a node system with a lot of sonar-like \textit{heads} which are mainly used in localisation.\cite{Dispert}
This is just a symbolic help to insert also this very special node in the translation system.

\begin{figure}[H]
   \centering
   \includegraphics{pic/medusa.jpg}%
   \caption{A first generation Medusa. Image source: \url{nesl.ee.ucla.edu}}
   \label{Medusapic}%
\end{figure}


\subsubsection{RenesasTranslator class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/RenesasTranslator.png}%
   \caption{RenesasTranslator class, dictionary class for Renesas}
   \label{RenesasTranslatorpic}%
\end{figure}

As the Renesas ZMD28-BRD is used as our main development board we included a full class for temperature sensing. It is a very 
basic hardware programming on the node to not complicate the whole project. It was provided by the laboratory assistant Stephan Koss.

The class itself is mainly a dictionary which is used for the translation process.

\newpage
\subsection{SerialReader class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/SerialReader.png}%
   \caption{SerialReader class, main class for reading data from serial port}
   \label{SerialReaderpic}%
\end{figure}

\textit{SerialReader} is used for the hardware part. It is highly configuarble through parametres and even more through code. As the
serial RS232 connector utilizes a big amount of different configuration parametres a possible adaptor will surely have to look inside the
programming. It is the main component which must be started.\footnote{Also the database is important if you don't want to rely on sqlite.}

\newpage
\subsection{Webserver class}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.5\textwidth]{pic/Webserver.png}%
   \caption{Webserver class, containing the webserver}
   \label{Webserverpic}%
\end{figure}

The \textit{Webserver} class can be seen as the \textit{View} part of the MVC pattern, as it allows and restricts the access and the requests of a user to this specified methods.

The class uses the Cherrypy webserver framework.\footnote{The CherryPy webserver is a open source project hosted on \url{http://www.cherrypy.org/}} A standalone webserver written completely in Python. The advantage of this fact is that the dependency of project is reduced to Python instead of the use of a big and resource hungry webserver like Apache2. Also the easy and fast development of methods/pages which comes with the framework.

For demonstrational purpose of the simplicity of CherryPy an extract of the \textit{Webserver} class is presented. As it can bee seen, it is already enough to define a method to receive a functional site. 
\begin{lstlisting}[language=Python]
import Controller
import cherrypy
from cherrypy import expose

class Webserver:
    @expose
    def index(self):
        return "WSN-Server is up and running"
       
\end{lstlisting}

To see if this method works, the user has to call \url{http://localhost:8080/index} and will receive the status of the webserver.


\section{Custom Installation}
\label{sec:install}

Custom installation is only required when not using the provided disc image.

\begin{enumerate}
    \item Install a Linux of your chosen flavour. Preferrably use Debian.
    \item Install git\footnote{\textit{apt-get install git}}
    \item Download and install cherrypy\footnote{\url{http://www.cherrypy.org/wiki/CherryPyDownload} or on Debian \textit{apt-get install python-cherrypy}}
    \item \textit{Optionally:} Install a MySQL server and proper SQL bindings for increased functionality\footnote{\textit{apt-get install mysql-server mysql-client libmysqlclient15-dev python-mysqldb}}
\end{enumerate}

The last step is to use a proper user-account\footnote{root not recommended but put the user in the appropriate group for accessing serial connection} and
get the most recent development version with \textit{git clone git@github.com:Phialo/wsnserver.git}.

Finally, you change directory to the project and run \textit{python SerialReader.py -h} to see available options.

[KAMIL BESCHREIBT HIER WIE DER WEBSERVER ZU STARTEN IST UND ERGAENZT AUCH DAS GITHUB-HELPDINGSDA]
